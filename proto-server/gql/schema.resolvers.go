package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"errors"
	"fmt"
	"proto-server/gql/generated"
	"proto-server/gql/model"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// CreateNode is the resolver for the createNode field.
func (r *mutationResolver) CreateNode(ctx context.Context, id string, input model.NodeCreate) (*model.Node, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	// TODO: throw error if trying to create node with same id
	query := `
		CREATE (n:Node {id: $id})
		SET n.text = $text 
		SET n.x = $x 
		SET n.y = $y 
		RETURN n`
	params := map[string]interface{}{
		"id":   id,
		"text": input.Text,
		"x":    input.X,
		"y":    input.Y,
	}

	result, err := session.Run(ctx, query, params)
	if err != nil {
		return nil, err
	}

	var errorPrefix = fmt.Sprintf("creating node with id %s", id)

	if !result.Next(ctx) {
		return nil, fmt.Errorf("%s: empty response from db", errorPrefix)
	}

	var record = result.Record()

	response, err := nodeFromRecord(record)
	if err != nil {
		return nil, fmt.Errorf("%s: %s", errorPrefix, err)
	}
	return response, nil
}

// UpdateNode is the resolver for the updateNode field.
func (r *mutationResolver) UpdateNode(ctx context.Context, id string, input model.NodeUpdate) (*model.Node, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	query := `
	MATCH (n:Node {id: $id})
	SET n.text = CASE WHEN $text IS NOT NULL THEN $text ELSE n.text END
	SET n.x = CASE WHEN $x IS NOT NULL THEN $x ELSE n.x END
	SET n.y = CASE WHEN $y IS NOT NULL THEN $y ELSE n.y END
	RETURN n`
	params := map[string]interface{}{
		"id":   id,
		"text": input.Text,
		"x":    input.X,
		"y":    input.Y,
	}

	result, err := session.Run(ctx, query, params)
	if err != nil {
		return nil, err
	}

	var errorPrefix = fmt.Sprintf("updating node with id %s", id)

	if !result.Next(ctx) {
		return nil, fmt.Errorf("%s: empty response from db", errorPrefix)
	}

	var record = result.Record()

	response, err := nodeFromRecord(record)
	if err != nil {
		return nil, fmt.Errorf("%s: %s", errorPrefix, err)
	}
	return response, nil
}

// DeleteNode is the resolver for the deleteNode field.
func (r *mutationResolver) DeleteNode(ctx context.Context, id string) (*string, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	query := `
		MATCH (n:Node)
		WHERE n.id = $id
		DETACH DELETE n`
	params := map[string]interface{}{
		"id": id,
	}

	_, err := session.Run(ctx, query, params)
	if err != nil {
		return nil, err
	}

	return &id, nil
}

// CreateEdge is the resolver for the createEdge field.
func (r *mutationResolver) CreateEdge(ctx context.Context, srcID string, destID string, label *string) (*model.Edge, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	if label != nil {
		return nil, errors.New("label not yet supported for create edge")
	}

	query := `
		MATCH (src), (dest)
		WHERE src.id = $srcId AND dest.id = $destId
		CREATE (src)-[edge:LINKED]->(dest)
	`
	params := map[string]interface{}{
		"srcId":  srcID,
		"destId": destID,
	}

	_, err := session.Run(ctx, query, params)
	if err != nil {
		return nil, err
	}

	response := &model.Edge{
		Label:  "LINKED",
		Source: srcID,
		Target: destID,
	}

	return response, nil
}

// DeleteEdge is the resolver for the deleteEdge field.
func (r *mutationResolver) DeleteEdge(ctx context.Context, srcID string, destID string, label *string) (*model.Edge, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	query := `
		MATCH (a)-[e:LINKED]-(b)
		WHERE a.id = $src AND b.id = $dest
		DELETE e
		RETURN { source: $src, label: type(e), target: $dest } as edge
	`
	params := map[string]interface{}{
		"src":  srcID,
		"dest": destID,
	}

	_, err := session.Run(ctx, query, params)
	if err != nil {
		return nil, err
	}

	response := &model.Edge{
		Label:  "LINKED",
		Source: srcID,
		Target: destID,
	}

	return response, nil
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (*model.Node, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	// TODO: throw error if trying to create node with same id
	query := `
		MATCH (n:Node {id: $id})
		RETURN n`
	params := map[string]interface{}{
		"id": id,
	}

	result, err := session.Run(ctx, query, params)
	if err != nil {
		return nil, err
	}

	var errorPrefix = fmt.Sprintf("getting node with id %s", id)

	if !result.Next(ctx) {
		return nil, fmt.Errorf("%s: empty response from db", errorPrefix)
	}

	var record = result.Record()

	response, err := nodeFromRecord(record)
	if err != nil {
		return nil, fmt.Errorf("%s: %s", errorPrefix, err)
	}
	return response, nil
}

// Edge is the resolver for the edge field.
func (r *queryResolver) Edge(ctx context.Context, srcID string, destID string) (*model.Edge, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	defer session.Close(ctx)

	query := `
		MATCH (n1)-[e:LINKED]->(n2)
		WHERE n1.id = $src AND n2.id = $dest
		RETURN { source: $src, label: type(e), target: $dest } as edge`
	params := map[string]interface{}{
		"src":  srcID,
		"dest": destID,
	}

	result, err := session.Run(ctx, query, params)
	if err != nil {
		return nil, err
	}

	var errorPrefix = fmt.Sprintf("getting edge between %s and %s", srcID, destID)

	if !result.Next(ctx) {
		return nil, fmt.Errorf("%s: empty response from db", errorPrefix)
	}

	var record = result.Record()

	response, err := edgeFromRecord(record)
	if err != nil {
		return nil, fmt.Errorf("%s: %s", errorPrefix, err)
	}
	return response, nil
}

// Graph is the resolver for the graph field.
func (r *queryResolver) Graph(ctx context.Context, nodeType *string) (*model.GraphFull, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeRead})
	defer session.Close(ctx)

	query := fmt.Sprintf(`
		MATCH (node:%s)
		MATCH (a:%s)-[e:LINKED]->(b:%s)
		RETURN collect(distinct node) as nodes, collect(distinct { source: a.id, label: type(e), target: b.id }) as edges
	`, *nodeType, *nodeType, *nodeType)
	params := map[string]interface{}{}

	result, err := session.Run(ctx, query, params)

	if err != nil {
		return nil, err
	}

	var graph *model.GraphFull
	var nodesResult []*model.Node
	var edgesResult []*model.Edge
	var errorPrefix = "getting graph by node type"

	if !result.Next(ctx) {
		return nil, fmt.Errorf("%s: empty response from db", errorPrefix)
	}

	var record = result.Record()

	edgesResult, err = edgesFromRecord(record)
	if err != nil {
		return nil, fmt.Errorf("%s: %s", errorPrefix, err)
	}

	nodesResult, err = nodesFromRecord(record)
	if err != nil {
		return nil, fmt.Errorf("%s: %s", errorPrefix, err)
	}

	graph = &model.GraphFull{
		Nodes: nodesResult,
		Edges: edgesResult,
	}

	return graph, nil
}

// GetNodesByDepth is the resolver for the getNodesByDepth field.
func (r *queryResolver) GetNodesByDepth(ctx context.Context, id string, depth int) ([]*model.GraphFull, error) {
	session := r.Driver.NewSession(ctx, neo4j.SessionConfig{AccessMode: neo4j.AccessModeRead})
	defer session.Close(ctx)

	// TODO: Support bidirectional relationships
	query := fmt.Sprintf(`
		MATCH (n:Node)-[:LINKED*0..%d]->(linked:Node)
		WHERE n.id = $id
		WITH n, collect(distinct linked) as nodes
		UNWIND nodes as node
		MATCH (node)-[e:LINKED]->(target:Node)
		RETURN nodes, collect({ source: node.id, label: type(e), target: target.id }) as edges
	`, depth)
	params := map[string]interface{}{
		"id": id,
	}

	result, err := session.Run(ctx, query, params)

	if err != nil {
		return nil, err
	}

	var nodeGraphs []*model.GraphFull
	var nodesResult []*model.Node
	var edgesResult []*model.Edge
	var errorPrefix = "getting nodes by depth"

	if !result.Next(ctx) {
		return nil, fmt.Errorf("%s: empty response from db", errorPrefix)
	}

	var record = result.Record()

	edgesResult, err = edgesFromRecord(record)
	if err != nil {
		return nil, fmt.Errorf("%s: %s", errorPrefix, err)
	}

	nodesResult, err = nodesFromRecord(record)
	if err != nil {
		return nil, fmt.Errorf("%s: %s", errorPrefix, err)
	}

	nodeGraphs = append(nodeGraphs, &model.GraphFull{
		Nodes: nodesResult,
		Edges: edgesResult,
	})

	return nodeGraphs, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
